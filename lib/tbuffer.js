// Generated by LiveScript 1.2.0
(function(){
  var EE, Selection, OP, TBuffer, exports;
  EE = require('events').EventEmitter;
  Selection = require('./selection');
  OP = require('./ops');
  TBuffer = (function(superclass){
    var prototype = extend$((import$(TBuffer, superclass).displayName = 'TBuffer', TBuffer), superclass).prototype, constructor = TBuffer;
    function TBuffer(poke, index){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.poke = poke;
      this$.index = index;
      this$['delete'] = bind$(this$, 'delete', prototype);
      this$.insert = bind$(this$, 'insert', prototype);
      this$.commit = bind$(this$, 'commit', prototype);
      this$.fullHistory = bind$(this$, 'fullHistory', prototype);
      this$.redo = bind$(this$, 'redo', prototype);
      this$._redo = bind$(this$, '_redo', prototype);
      this$.undo = bind$(this$, 'undo', prototype);
      this$.apply = bind$(this$, 'apply', prototype);
      this$._parsePos = bind$(this$, '_parsePos', prototype);
      this$.offsetPos = bind$(this$, 'offsetPos', prototype);
      this$.line = bind$(this$, 'line', prototype);
      this$.selections = [Selection(this$, 1, 1)];
      this$.history = [];
      this$.historyIndex = -1;
      this$.commits = [this$.history];
      this$.commitIndex = 0;
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.line = function(i){
      return this.lines()[i] || "";
    };
    prototype.offsetPos = function(x, y, ox, oy){
      var offset, lines, line;
      if (typeof oy !== 'number') {
        offset = ox;
        lines = this.lines();
        while (offset > 0) {
          if (y >= lines.length || y <= 0) {
            break;
          }
          line = lines[y];
          if (x >= line.length) {
            y += 1;
          } else if (x <= 0) {
            y -= 1;
          } else if (offset < 0) {
            x -= 1;
            offset -= 1;
          } else {
            x += 1;
            offset += 1;
          }
        }
        return [x, y];
      } else {
        return [x + ox, y + oy];
      }
    };
    prototype._parsePos = function(x, y){
      var lines;
      lines = this.lines();
      if (y === 'end') {
        y = lines.length - 1;
      }
      if (y === 'home') {
        y = 0;
      }
      if (y < 0) {
        y += lines.length;
      }
      if (x === 'end') {
        x = lines[y].length;
      }
      if (x === 'home') {
        x = 0;
      }
      if (x < 0) {
        x += lines[y].length;
      }
      return [x, y];
    };
    prototype.apply = function(op, hist){
      var data;
      hist == null && (hist = true);
      this.emit('apply', op);
      data = op.apply(this);
      if (hist) {
        this.history.push([op, data]);
        this.historyIndex += 1;
      }
      return this;
    };
    prototype.undo = function(){
      var commit, hist;
      if (this.history.length <= 0 || this.historyIndex < 0) {
        if (this.commitIndex < 1) {
          throw new Error("Nothing to undo");
        }
        this.commitIndex -= 1;
        commit = this.commits[this.commitIndex];
        this.history = commit;
        this.historyIndex = commit.length - 1;
        while (this.historyIndex > -1) {
          this.undo();
        }
      } else {
        hist = this.history[this.historyIndex];
        hist[0].unapply(this, hist[1]);
        this.historyIndex -= 1;
      }
      return this;
    };
    prototype._redo = function(){
      if (this.historyIndex >= this.history.length - 1) {
        throw new Error("Nothing to redo");
      }
      this.historyIndex += 1;
      return this.apply(this.history[this.historyIndex][0], false);
    };
    prototype.redo = function(){
      if (this.commitIndex >= this.commits.length - 1) {
        this._redo();
      } else {
        if (this.commitIndex >= this.commits.length - 1) {
          throw new Error("Nothing to redo");
        }
        while (this.historyIndex < this.history.length - 1) {
          this._redo();
        }
        this.commitIndex += 1;
        this.history = this.commits[this.commitIndex];
        this.historyIndex = -1;
      }
      return this;
    };
    prototype.fullHistory = function(){
      var i$, ref$, len$, commit, j$, len1$, op, results$ = [];
      for (i$ = 0, len$ = (ref$ = this.commits).length; i$ < len$; ++i$) {
        commit = ref$[i$];
        for (j$ = 0, len1$ = commit.length; j$ < len1$; ++j$) {
          op = commit[j$];
          results$.push(op);
        }
      }
      return results$;
    };
    prototype.commit = function(){
      this.history = [];
      this.historyIndex = -1;
      this.commits.push(this.history);
      this.commitIndex += 1;
      return this;
    };
    prototype.insert = function(x, y, text){
      var i$, ref$, len$, selection, results$ = [];
      if (typeof x === 'string' && !(y != null && text != null)) {
        text = x;
        for (i$ = 0, len$ = (ref$ = this.selections).length; i$ < len$; ++i$) {
          selection = ref$[i$];
          results$.push(selection.insert(text));
        }
        return results$;
      } else {
        return this.apply(OP.insert(x, y, text));
      }
    };
    prototype['delete'] = function(x, y, length){
      var text, i$, ref$, len$, selection, results$ = [];
      if (typeof x === 'string' && !(y != null && (typeof text != 'undefined' && text !== null))) {
        text = x;
        for (i$ = 0, len$ = (ref$ = this.selections).length; i$ < len$; ++i$) {
          selection = ref$[i$];
          results$.push(selection['delete'](text));
        }
        return results$;
      } else {
        return this.apply(OP['delete'](x, y, length));
      }
    };
    return TBuffer;
  }(EE));
  exports = module.exports = TBuffer;
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
